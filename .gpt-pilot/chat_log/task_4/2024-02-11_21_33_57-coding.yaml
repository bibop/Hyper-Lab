endpoint: OPENAI
model: gpt-4-1106-preview
messages:
- role: system
  content: You are a full stack software developer who works in a software development agency. You write very modular code.
    Your job is to implement tasks that your tech lead assigns you.
- role: user
  content: "You're a senior software developer implementing changes in one file in the project.\nBased on the provided instructions\
    \ and full file list, identify the file\nthat needs to be modified.\n\nAll files in the project:\n\n\n### /package.json\n\
    \n```\n{\n  \"name\": \"ai_hyperlab\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"index.js\"\
    ,\n  \"directories\": {\n    \"test\": \"tests\"\n  },\n  \"scripts\": {\n    \"start\": \"node index.js\",\n    \"test\"\
    : \"echo \\\"Error: no test specified\\\" && exit 1\"\n  },\n  \"keywords\": [],\n  \"author\": \"\",\n  \"license\":\
    \ \"ISC\",\n  \"dependencies\": {\n    \"bcryptjs\": \"^2.4.3\",\n    \"dotenv\": \"^16.4.1\",\n    \"express\": \"^4.18.2\"\
    ,\n    \"express-validator\": \"^7.0.1\",\n    \"jsonwebtoken\": \"^9.0.2\",\n    \"mongoose\": \"^8.1.1\",\n    \"passport\"\
    : \"^0.7.0\",\n    \"passport-jwt\": \"^4.0.1\",\n    \"passport-local\": \"^1.0.0\"\n  }\n}\n\n```\n\n\n### /index.js\n\
    \n```\nconst express = require('express');\nrequire('dotenv').config();\nconst connectDB = require('./config/database');\n\
    \nconst app = express();\n\n// Database Connection\nconnectDB().catch(err => console.log(err));\n\nconst passport = require('./config/passport');\n\
    \n// Initialize Passport\napp.use(passport.initialize());\n\n// Middleware for parsing JSON and urlencoded form data\n\
    app.use(express.json());\napp.use(express.urlencoded({ extended: true }));\n\n// Centralized Routing Module\nconst setupRoutes\
    \ = require('./routes');\nsetupRoutes(app);\n// app.use('/test-user', require('./routes/testUserRoutes'));\n\n// Error\
    \ handling middleware\nconst errorHandler = require('./middleware/errorHandler');\napp.use(errorHandler);\n\nconst PORT\
    \ = process.env.PORT || 5000;\nconsole.log('Attempting to listen on port', PORT);\napp.listen(PORT, () => {\n  console.log(`Server\
    \ is running on port ${PORT}`);\n});\n```\n\n\n### config/database.js\n\n```\nconst mongoose = require('mongoose');\n\n\
    const connectDB = async () => {\n  try {\n    await mongoose.connect(process.env.MONGO_URI);\n    console.log('MongoDB\
    \ Connected');\n  } catch (err) {\n    console.error(err.message);\n    process.exit(1);\n  }\n};\n\nmodule.exports =\
    \ connectDB;\n```\n\n\n### models/User.js\n\n```\nconst mongoose = require('mongoose');\nconst bcrypt = require('bcryptjs');\n\
    const Schema = mongoose.Schema;\n\n// User Schema Definition\nconst UserSchema = new Schema({\n  username: {\n    type:\
    \ String,\n    required: true,\n    unique: true,\n    trim: true\n  },\n  email: {\n    type: String,\n    required:\
    \ true,\n    unique: true,\n    trim: true,\n    lowercase: true\n  },\n  password: {\n    type: String,\n    required:\
    \ true\n  },\n  refreshTokens: [{\n    token: {\n      type: String,\n      required: true\n    }\n  }],\n  createdAt:\
    \ {\n    type: Date,\n    default: Date.now\n  },\n  updatedAt: {\n    type: Date,\n    default: Date.now\n  }\n});\n\n\
    // User Schema Pre-save Hook\nUserSchema.pre('save', function(next) {\n  if (!this.isModified('password')) {\n    return\
    \ next();\n  }\n  bcrypt.genSalt(10, (err, salt) => {\n    if (err) return next(err);\n    bcrypt.hash(this.password,\
    \ salt, (err, hash) => {\n      if (err) return next(err);\n      this.password = hash;\n      next();\n    });\n  });\n\
    });\n\n// Ensuring proper environment variable usage\nif (!process.env.JWT_SECRET) {\n  throw new Error('Missing JWT_SECRET\
    \ environment variable in .env file');\n}\n\n// Method to compare password for authentication\nUserSchema.methods.comparePassword\
    \ = function(candidatePassword, cb) {\n  bcrypt.compare(candidatePassword, this.password, (err, isMatch) => {\n    if\
    \ (err) return cb(err);\n    cb(null, isMatch);\n  });\n};\n\nconst User = mongoose.model('User', UserSchema);\n\nmodule.exports\
    \ = User;\n```\n\n\n### /.gitignore\n\n```\n# .gitignore\n\n# Dependency directories\nnode_modules/\n\n# macOS system\
    \ files\n.DS_Store\n\n# Environment variables\n.env\n\n# Production build directory\n/dist\n\n# Local development\n/local\n\
    /.pnp\n.pnp.js\n\n# Debug logs\nnpm-debug.log*\nyarn-debug.log*\nyarn-error.log*\n\n# Compiled files\n/**/*.js\n/**/*.jsx\n\
    /**/*.ts\n/**/*.tsx\n/**/*.d.ts\n\n# Editor directories and files\n/.vscode\n/.idea\n/*.sublime-workspace\n/*.sublime-project\n\
    \n# Log files\n/logs\n*.log\nnpm-debug.log*\nyarn-debug.log*\nyarn-error.log*\n\n# Runtime data\npids\n*.pid\n*.seed\n\
    *.pid.lock\n\n# Directory for instrumented libs generated by jscoverage/JSCover\n/lib-cov\n\n# Coverage directory used\
    \ by tools like istanbul\n/coverage\n/.nyc_output\n\n# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)\n\
    /.grunt\n\n# Optional npm cache directory\n.npm\n\n# Optional eslint cache\n.eslintcache\n\n# TypeScript cache\n*.tsbuildinfo\n\
    \n# Optional REPL history\n.node_repl_history\n\n# Output of 'npm pack'\n*.tgz\n\n# Yarn Integrity file\n.yarn-integrity\n\
    \n# parcel-bundler cache (https://parceljs.org/)\n.cache\n.parcel-cache\n\n# Next.js build output\n.next\n.out\n\n# Nuxt.js\
    \ build / generate output\n.nuxt\ndist\n\n# Gatsby files\n.cache/\npublic\n\n# vuepress build output\n.vuepress/dist\n\
    \n# Serverless directories\n.serverless/\n\n# FuseBox cache\n.fusebox/\n\n```\n\n\n### /.env\n\n```\nMONGO_URI=mongodb://localhost:27017/ai_hyperlab\n\
    PORT=3000\nJWT_SECRET=XLq0qi3CMAw2ahaXJWlKE3UboN13C2Gt4QFfCu2yPVtIy\nJWT_REFRESH_SECRET=pkz1q4DJ5tiaBTZohoAD5wwNnPDqQAmGscBH5aO0eBvR\n\
    ```\n\n\n### routes/users.js\n\n```\n// 722 is likely to be a typo or misplaced number, remove it\nconst express = require('express');\n\
    const router = express.Router();\nconst User = require('../models/User');\n\nrouter.get('/test-db', async (req, res) =>\
    \ {\n  try {\n    const userCount = await User.countDocuments();\n    res.status(200).json({ msg: 'Database connected.\
    \ User collection count: ' + userCount });\n  } catch (err) {\n    res.status(500).json({ errors: [{ msg: 'Database connection\
    \ error' }] });\n  }\n});\n\nrouter.get('/test-user', async (req, res) => {\n  res.status(200).json({ msg: 'Test User\
    \ endpoint hit' });\n});\n\nrouter.post('/register-test-user', async (req, res) => {\n  try {\n    let existingUser =\
    \ await User.findOne({ username: 'testuser' });\n    if (existingUser) {\n      return res.status(409).json({ msg: 'Test\
    \ user already exists.' });\n    }\n\n    const newUser = new User({\n      username: 'testuser',\n      email: 'testuser@example.com',\n\
    \      password: 'password123',\n    });\n\n    const savedUser = await newUser.save();\n    \n    res.status(201).json({\
    \ id: savedUser._id, msg: 'Test user created successfully.' });\n  } catch (err) {\n    console.error(err);\n    res.status(500).json({\
    \ error: 'Server error during test user creation: ' + err.message });\n  }\n});\n\n// Export the router to be used as\
    \ middleware\nmodule.exports = router;\n```\n\n\n### routes/index.js\n\n```\nconst userRoutes = require('./users');\n\
    const authRoutes = require('./auth');\nconst apiRoutes = require('./api');  // Added line for requiring API routes\nconst\
    \ projectRoutes = require('./projectRoutes');\n\nmodule.exports = function(app) {\n  app.use('/users', userRoutes);\n\
    \  app.use('/auth', authRoutes);\n  app.use('/api', apiRoutes);\n  app.use('/projects', projectRoutes);\n\n  app.get('/health',\
    \ (req, res) => {\n    res.status(200).send('Server healthy');\n  });\n};\n```\n\n\n### routes/auth.js\n\n```\nconst express\
    \ = require('express');\nconst router = express.Router();\nconst { body } = require('express-validator');\nconst authController\
    \ = require('../controllers/authController');\n\nconst registerValidator = [\n  body('username').not().isEmpty().withMessage('Username\
    \ is required'),\n  body('email').isEmail().withMessage('Please include a valid email'),\n  body('password').isLength({\
    \ min: 6 }).withMessage('Password must be at least 6 characters')\n];\n\nconst loginValidator = [\n  body('email').isEmail().withMessage('Please\
    \ include a valid email'),\n  body('password').exists().withMessage('Password is required')\n];\n\nrouter.post('/register',\
    \ registerValidator, authController.registerUser);\nrouter.post('/login', loginValidator, authController.loginUser);\n\
    router.post('/refresh-token', authController.refreshToken);\n\nmodule.exports = router;\n```\n\n\n### middleware/errorHandler.js\n\
    \n```\nconst errorHandler = (err, req, res, next) => {\n  console.error(err.stack);\n  res.status(500).json({\n    errors:\
    \ [{\n      msg: 'Internal Server Error',\n      error: (process.env.NODE_ENV === 'development') ? err.stack : {}\n  \
    \  }]\n  });\n};\n\nmodule.exports = errorHandler;\n\n```\n\n\n### routes/testUserRoutes.js\n\n```\nconst express = require('express');\n\
    const router = express.Router();\nconst User = require('../models/User');\nrouter.post('/create', async (req, res) =>\
    \ {\n  const newUser = new User({ username: 'testuser', email: 'testuser@example.com', password: 'password123' });\n \
    \ try {\n    const user = await newUser.save();\n    res.status(201).json({ id: user._id, msg: 'Test user successfully\
    \ created' });\n  } catch (err) {\n    res.status(500).json({ error: err.message });\n  }\n});\nmodule.exports = router;\n\
    ```\n\n\n### config/passport.js\n\n```\nconst passport = require('passport');\nconst LocalStrategy = require('passport-local').Strategy;\n\
    const User = require('../models/User');\n\npassport.use(new LocalStrategy({ usernameField: 'email' }, (email, password,\
    \ done) => {\n  User.findOne({ email: email.toLowerCase() }, (err, user) => {\n    if (err) return done(err);\n    if\
    \ (!user) return done(null, false, { message: 'Invalid credentials' });\n\n    user.comparePassword(password, (err, isMatch)\
    \ => {\n      if (err) return done(err);\n      if (isMatch) {\n        return done(null, user);\n      } else {\n   \
    \     return done(null, false, { message: 'Invalid credentials' });\n      }\n    });\n  });\n}));\npassport.serializeUser((user,\
    \ done) => {\n  done(null, user._id);\n});\npassport.deserializeUser((id, done) => {\n  User.findById(id, function(err,\
    \ user) {\n    done(err, user);\n  });\n});\n\nmodule.exports = passport;\n```\n\n\n### middleware/auth.js\n\n```\nconst\
    \ jwt = require('jsonwebtoken');\n\nmodule.exports = (req, res, next) => {\n  // Your existing jwt authentication middleware\
    \ code\n  // Make sure it attaches the authenticated user to 'req.user'\n};\n```\n\n\n### controller/userController.js\n\
    \n```\nconst bcrypt = require('bcryptjs');\nconst jwt = require('jsonwebtoken');\nconst User = require('../models/User');\n\
    const { validationResult } = require('express-validator');\nconst passport = require('passport');\n\nexports.registerUser\
    \ = async (req, res) => {\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return res.status(400).json({\
    \ errors: errors.array() });\n  }\n\n  const { username, email, password } = req.body;\n\n  try {\n    let user = await\
    \ User.findOne({ email });\n    if (user) {\n      return res.status(400).json({ msg: 'User already exists' });\n    }\n\
    \    \n    user = new User({\n      username,\n      email,\n      password\n    });\n\n    await user.save();\n\n   \
    \ const payload = {\n      user: {\n        id: user.id\n      }\n    };\n\n    jwt.sign(\n      payload,\n      process.env.JWT_SECRET,\n\
    \      { expiresIn: '2h' },\n      (err, token) => {\n        if (err) throw err;\n        res.status(201).json({ token\
    \ });\n      }\n    );\n  } catch (err) {\n    console.error(err.message);\n    res.status(500).send('Server Error');\n\
    \  }\n};\n\nexports.loginUser = async (req, res) => {\n  const errors = validationResult(req);\n  if (!errors.isEmpty())\
    \ {\n    return res.status(400).json({ errors: errors.array() });\n  }\n\n  const { email, password } = req.body;\n\n\
    \  try {\n    let user = await User.findOne({ email });\n    if (!user) {\n      return res.status(400).json({ msg: 'Invalid\
    \ Credentials' });\n    }\n\n    const isMatch = await bcrypt.compare(password, user.password);\n    if (!isMatch) {\n\
    \      return res.status(400).json({ msg: 'Invalid Credentials' });\n    }\n\n    const payload = {\n      user: {\n \
    \       id: user.id\n      }\n    };\n\n    jwt.sign(\n      payload,\n      process.env.JWT_SECRET,\n      { expiresIn:\
    \ '2h' },\n      (err, token) => {\n        if (err) throw err;\n        res.json({ token });\n      }\n    );\n  } catch\
    \ (err) {\n    console.error(err.message);\n    res.status(500).send('Server Error');\n  }\n};\n\nexports.refreshToken\
    \ = async (req, res) => {\n  const { refreshToken } = req.body;\n  if (!refreshToken) {\n    return res.status(401).json({\
    \ msg: 'Refresh Token is required' });\n  }\n  try {\n    const decoded = jwt.verify(refreshToken, process.env.JWT_REFRESH_SECRET);\n\
    \    const user = await User.findById(decoded.user.id);\n    if (!user) {\n      return res.status(401).json({ msg: 'User\
    \ not found' });\n    }\n    if (!user.refreshTokens.find(token => token.token === refreshToken)) {\n      return res.status(403).json({\
    \ msg: 'Refresh Token is invalid' });\n    }\n    user.refreshTokens = user.refreshTokens.filter(token => token.token\
    \ !== refreshToken);\n    const newPayload = { user: { id: user.id }};\n    const newAccessToken = jwt.sign(newPayload,\
    \ process.env.JWT_SECRET, { expiresIn: '1h' });\n    const newRefreshToken = jwt.sign(newPayload, process.env.JWT_REFRESH_SECRET,\
    \ { expiresIn: '7d' });\n    user.refreshTokens.push({ token: newRefreshToken });\n    await user.save();\n    return\
    \ res.json({ accessToken: newAccessToken, refreshToken: newRefreshToken });\n  } catch (err) {\n    return res.status(403).json({\
    \ msg: 'Refresh Token is invalid or expired' });\n  }\n};\n\n```\n\n\n### routes/api.js\n\n```\nconst express = require('express');\n\
    const router = express.Router();\nconst jwtAuthMiddleware = require('../middleware/jwtAuthMiddleware');\n\nrouter.get('/protected',\
    \ jwtAuthMiddleware, (req, res) => {\n  res.json({ msg: 'This is a protected endpoint.' });\n});\n\nmodule.exports = router;\n\
    \n```\n\n\n### /README.md\n\n```\n## Production Secrets Management\n\nFor production deployment, ensure that the `JWT_SECRET`\
    \ is stored securely and not hardcoded in the `.env` file. Use your platform's secret management service or environment\
    \ variable configuration to set `JWT_SECRET` securely.\n```\n\n\n### controllers/authController.js\n\n```\nconst bcrypt\
    \ = require('bcryptjs');\nconst User = require('../models/User');\nconst { validationResult } = require('express-validator');\n\
    const jwtUtil = require('../utils/jwtUtil');\n\nexports.registerUser = async (req, res) => {\n  const errors = validationResult(req);\n\
    \  if (!errors.isEmpty()) {\n    return res.status(400).json({ errors: errors.array() });\n  }\n\n  const { username,\
    \ email, password } = req.body;\n\n  try {\n    let user = await User.findOne({ email });\n    if (user) {\n      return\
    \ res.status(400).json({ msg: 'User already exists' });\n    }\n    \n    user = new User({\n      username,\n      email,\n\
    \      password\n    });\n\n    await user.save();\n\n    const payload = {\n      user: {\n        id: user.id\n    \
    \  }\n    };\n\n    jwtUtil.signJwt(payload, process.env.JWT_SECRET, '2h')\n      .then(token => res.status(201).json({\
    \ token }))\n      .catch(err => {\n        console.error(err.message);\n        res.status(500).send('Server Error');\n\
    \      });\n\n  } catch (err) {\n    console.error(err.message);\n    res.status(500).send('Server Error');\n  }\n};\n\
    \nexports.loginUser = async (req, res) => {\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n   \
    \ return res.status(400).json({ errors: errors.array() });\n  }\n\n  const { email, password } = req.body;\n\n  try {\n\
    \    let user = await User.findOne({ email });\n    if (!user) {\n      return res.status(400).json({ msg: 'Invalid Credentials'\
    \ });\n    }\n\n    const isMatch = await bcrypt.compare(password, user.password);\n    if (!isMatch) {\n      return\
    \ res.status(400).json({ msg: 'Invalid Credentials' });\n    }\n\n    const payload = {\n      user: {\n        id: user.id\n\
    \      }\n    };\n\n    jwtUtil.signJwt(payload, process.env.JWT_SECRET, '2h')\n      .then(token => res.json({ token\
    \ }))\n      .catch(err => {\n        console.error(err.message);\n        res.status(500).send('Server Error');\n   \
    \   });\n\n  } catch (err) {\n    console.error(err.message);\n    res.status(500).send('Server Error');\n  }\n};\n\n\
    exports.refreshToken = async (req, res) => {\n  const { refreshToken } = req.body;\n  if (!refreshToken) {\n    return\
    \ res.status(401).json({ msg: 'Refresh Token is required' });\n  }\n  try {\n    const decoded = await jwtUtil.verifyJwt(refreshToken,\
    \ process.env.JWT_REFRESH_SECRET);\n    const user = await User.findById(decoded.user.id);\n    if (!user) {\n      return\
    \ res.status(401).json({ msg: 'User not found' });\n    }\n\n    // Ensure the refresh token is still stored on the user\
    \ before creating new tokens\n    const refreshTokensMatch = user.refreshTokens.find(token => token.token === refreshToken);\n\
    \    user.refreshTokens = user.refreshTokens.filter(token => token.token !== refreshToken);\n    if (!refreshTokensMatch)\
    \ {\n      return res.status(403).json({ msg: 'Refresh Token is invalid' });\n    }\n\n    user.refreshTokens = user.refreshTokens.filter(token\
    \ => token.token !== refreshToken);\n    const newPayload = { user: { id: user.id }};\n    const newAccessToken = await\
    \ jwtUtil.signJwt(newPayload, process.env.JWT_SECRET, '1h');\n    const newRefreshToken = await jwtUtil.signJwt(newPayload,\
    \ process.env.JWT_REFRESH_SECRET, '7d');\n\n    user.refreshTokens.push({ token: newRefreshToken });\n    await user.save();\n\
    \n    return res.json({ accessToken: newAccessToken, refreshToken: newRefreshToken });\n\n  } catch (err) {\n    return\
    \ res.status(403).json({ msg: 'Refresh Token is invalid or expired' });\n  }\n};\n```\n\n\n### utils/jwtUtil.js\n\n```\n\
    const jwt = require('jsonwebtoken');\n\nexports.signJwt = (payload, secret, expiresIn) => {\n  return new Promise((resolve,\
    \ reject) => {\n    jwt.sign(payload, secret, { expiresIn }, (err, token) => {\n      if (err) {\n        reject(err);\n\
    \      } else {\n        resolve(token);\n      }\n    });\n  });\n};\n\nexports.verifyJwt = (token, secret) => {\n  return\
    \ new Promise((resolve, reject) => {\n    jwt.verify(token, secret, (err, decoded) => {\n      if (err) {\n        reject(err);\n\
    \      } else {\n        resolve(decoded);\n      }\n    });\n  });\n};\n\nexports.decodeJwt = (token) => {\n  return\
    \ jwt.decode(token);\n};\n```\n\n\n### middleware/jwtAuthMiddleware.js\n\n```\n// No change in the content of the code,\
    \ only the filename has been changed to jwtAuthMiddleware.js\nconst jwt = require('jsonwebtoken');\nconst User = require('../models/User');\n\
    \nmodule.exports = (req, res, next) => {\n  if (!req.headers.authorization) {\n    return res.status(401).json({ msg:\
    \ 'No Authorization header provided, authorization denied' });\n  }\n  const authHeaderParts = req.headers.authorization.split('\
    \ ');\n  if (authHeaderParts.length !== 2 || authHeaderParts[0] !== 'Bearer' || !authHeaderParts[1]) {\n    return res.status(401).json({\
    \ msg: 'Authorization header must be formatted as \\'Bearer [token]\\'' });\n  }\n\n  const token = authHeaderParts[1];\n\
    \  if (!token) {\n    console.error('No token provided');\n    return res.status(401).json({ msg: 'No token, authorization\
    \ denied' });\n  }\n\n  try {\n    const decoded = jwt.verify(token, process.env.JWT_SECRET);\n    User.findById(decoded.user.id)\n\
    \      .then((user) => {\n        if (!user) {\n          return res.status(401).json({ msg: 'User not found' });\n  \
    \      }\n        req.user = user;\n        next();\n      })\n      .catch((err) => {\n        console.error('Server\
    \ error during user authentication');\n        res.status(500).json({ msg: 'Server Error' });\n      });\n  } catch (e)\
    \ {\n    console.error('Invalid JWT token');\n    res.status(400).json({ msg: 'Token is not valid' });\n  }\n};\n```\n\
    \n\n### models/Project.js\n\n```\nconst mongoose = require('mongoose');\nconst Schema = mongoose.Schema;\n\nconst ProjectSchema\
    \ = new Schema({\n  name: {\n    type: String,\n    required: true\n  },\n  user: {\n    type: Schema.Types.ObjectId,\n\
    \    ref: 'User',\n    required: true\n  },\n  agents: [{\n    type: Schema.Types.ObjectId,\n    ref: 'Agent'\n  }],\n\
    \  createdAt: {\n    type: Date,\n    default: Date.now\n  }\n});\n\nconst Project = mongoose.model('Project', ProjectSchema);\n\
    module.exports = Project;\n```\n\n\n### models/Agent.js\n\n```\nconst mongoose = require('mongoose');\nconst Schema =\
    \ mongoose.Schema;\n\nconst AgentSchema = new Schema({\n  projectId: {\n    type: Schema.Types.ObjectId,\n    ref: 'Project',\n\
    \    required: true\n  },\n  name: {\n    type: String,\n    required: true\n  },\n  role: {\n    type: String,\n    enum:\
    \ ['boss', 'critic', 'worker'],\n    required: true\n  },\n  image: {\n    type: String,\n    default: ''\n  },\n  createdAt:\
    \ {\n    type: Date,\n    default: Date.now\n  }\n});\n\nconst Agent = mongoose.model('Agent', AgentSchema);\nmodule.exports\
    \ = Agent;\n```\n\n\n### routes/projectRoutes.js\n\n```\nconst express = require('express');\nconst router = express.Router();\n\
    const projectController = require('../controllers/projectController');\n\nrouter.post('/create', projectController.createProject);\n\
    router.post('/:projectId/agent', projectController.addAgentToProject);\n\nmodule.exports = router;\n```\n\n\n### controllers/projectController.js\n\
    \n```\nconst Project = require('../models/Project');\nconst Agent = require('../models/Agent');\n\nexports.createProject\
    \ = async (req, res) => {\n  try {\n    const { name } = req.body;\n\n    let project = new Project({ name, user: req.user._id\
    \ });\n    project = await project.save();\n\n    res.status(201).json({ project });\n  } catch (err) {\n    res.status(500).send('Server\
    \ Error');\n  }\n};\n\nexports.addAgentToProject = async (req, res) => {\n  try {\n    const { projectId } = req.params;\n\
    \    const { name, role } = req.body;\n\n    let project = await Project.findById(projectId);\n    if (!project) {\n \
    \     return res.status(404).json({ msg: 'Project not found' });\n    }\n\n    if (project.agents.length >= 8) {\n   \
    \   return res.status(400).json({ msg: 'Project already has the maximum number of agents' });\n    }\n\n    let agent\
    \ = new Agent({ name, role, projectId });\n    agent = await agent.save();\n    \n    project.agents.push(agent._id);\n\
    \    await project.save();\n\n    res.status(201).json({ agent });\n  } catch (err) {\n    res.status(500).send('Server\
    \ Error');\n  }\n};\n```\n\n\nInstructions:\nChange the listening port in the index.js file from 3000 to a different one,\
    \ such as 3001, that's not reserved or likely to be in use by another process. Locate the line where the PORT variable\
    \ is assigned from process.env.PORT or 3000 and replace it with process.env.PORT || 3001.\n\nOutput *ONLY* the file path,\
    \ relative to project root, in a single Markdown code block,\nwithout any comments or explanation, like this:\n```\npath/to/file\n\
    ```"
- role: user
  content: "**IMPORTANT**\nYou must respond with ONLY the JSON object, with NO additional text or explanation.\n\nHere is\
    \ the schema for the expected JSON object:\n```json\n{\n    \"file\": {\n        \"type\": \"string\",\n        \"description\"\
    : \"Path to the file that needs to be modified, relative to the project root.\"\n    }\n}\n```\n\n"
response: "```json\n{\n    \"file\": \"/index.js\"\n}\n```"
